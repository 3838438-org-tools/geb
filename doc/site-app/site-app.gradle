import org.apache.ivy.plugins.resolver.URLResolver
import org.apache.tools.ant.filters.*

apply plugin: "groovy"
apply plugin: "gae"

buildscript {
	repositories {
		add(new URLResolver()) {
			name = "Gaelyk Gradle Plugin"
			addArtifactPattern "http://cloud.github.com/downloads/bmuschko/gradle-gae-plugin/[module]-[revision].[ext]"
		}
		mavenCentral()
	}

	dependencies {
		classpath "com.google.appengine:appengine-tools-sdk:1.5.1"
		classpath ":gradle-gae-plugin:0.4"
	}
}

repositories {
	add(new URLResolver()) {
		name = "Gaelyk"
		addArtifactPattern "http://cloud.github.com/downloads/glaforge/gaelyk/[module]-[revision].[ext]"
	}
}

configurations {
	gaeSdk
}

// Also needed to be updated in buildscript block
appEngineVersion = "1.5.1"

dependencies {
	groovy "org.codehaus.groovy:groovy-all:1.8.0"
	
	compile "com.google.appengine:appengine-api-1.0-sdk:$appEngineVersion",
	        "com.google.appengine:appengine-api-labs:$appEngineVersion",
	        ":gaelyk:0.7"
	
	compile "oauth.signpost:signpost-core:1.2.1.1"
	gaeSdk "com.google.appengine:appengine-java-sdk:$appEngineVersion"
}

task downloadGaeSdk {
	sdkZip = configurations.gaeSdk.singleFile
	sdk = file("build/gaeSdk/${sdkZip.name[0..-5]}")
	
	inputs.file sdkZip
	outputs.dir "build/gaeSdk"
		
	doLast {
		mkdir "build/gaeSdk"
		copy {
			into "build/gaeSdk"
			from zipTree(sdkZip)
		}
	}
}

task configureGaeSdk(dependsOn: downloadGaeSdk) << {
	System.setProperty("appengine.sdk.root", downloadGaeSdk.sdk.absolutePath)
}

// modify all the gae* tasks provided by the gae plugin to not run until
// we install the gae sdk and set the appropriate system property
tasks.each {
	if (it.name.startsWith("gae")) {
		it.dependsOn configureGaeSdk
	}
}

// The version of manual to put under the “current” label
stableVersion = "0.6.0"

// The old versions of Geb we are including manuals for
oldManualVersions = ["0.6.0.RC1"]

def manualDependency = { "org.codehaus.geb:geb-manual:$it@zip" }
configurations {
	snapshotManual
	currentManual
	
	oldManualVersions.each {
		delegate."manual-$it"
	}
}

repositories {
	mavenLocal()
	mavenRepo urls: "https://nexus.codehaus.org/content/repositories/snapshots"
}

dependencies {
	snapshotManual project(":doc:manual")
	currentManual manualDependency(stableVersion)
	
	oldManualVersions.each {
		delegate."manual-$it" manualDependency(it)
	}
}

def findManualArtifacts = { configuration ->
	configuration.resolvedConfiguration.resolvedArtifacts.findAll {
		it.name == "geb-manual" && it.type == "zip"
	}.unique {
		// sometimes there are two of the same artifact in the configuration
		it.name
	}
}

def findManualArtifact = { configuration ->
	def artifacts = findManualArtifacts(configuration)
	assert artifacts.size() == 1 : "$configuration should have one manual artifact"
	artifacts.toList().first()
}

def explodeManual = { manualArtifact, label ->
	copy {
		from zipTree(manualArtifact.file)
		into "build/manual/manual/$label"
	}
}

task cleanManuals(type: Delete) {
	delete "$buildDir/manual"
}

task includeSnapshotManual(dependsOn: [configurations.snapshotManual, cleanManuals]) {
	doLast {
		explodeManual(findManualArtifact(configurations.snapshotManual), "snapshot")
	}
}

task includeCurrentManual(dependsOn: [configurations.currentManual, cleanManuals]) {
	doLast {
		explodeManual(findManualArtifact(configurations.currentManual), "current")
	}
}

def allVersionConfigurations = [configurations.currentManual] + oldManualVersions.collect { configurations["manual-$it"] } 
task includeVersionManuals(dependsOn: allVersionConfigurations + [cleanManuals]) {
	allVersionConfigurations.each { manualConfiguration ->
		doLast {
			def artifact = findManualArtifact(manualConfiguration)
			explodeManual(artifact, artifact.resolvedDependency.moduleVersion)
		}
	}
}

task includeManuals(dependsOn: [includeSnapshotManual, includeCurrentManual, includeVersionManuals])

task filter(type: Copy) {
	def siteVersion = project.hasProperty("liveSite") ? stableVersion.replace(".", "-") : "snapshot" 
	def properties = [version: siteVersion]

	["consumerKey", "consumerSecret", "accessToken", "secretToken"].each {
		def propertyName = "geb.twitter.$it"
		properties[propertyName] = project.hasProperty(propertyName) ? project.getProperty(propertyName) : ""
	}

	inputs.properties(properties)
	filter(ReplaceTokens, tokens: properties)
	from "src/main/webapp-filtered"
	into "build/exploded-war-filtered"
}

war {
	dependsOn filter, includeManuals
	from filter.destinationDir
	from "build/manual"
}

gae {
	appcfg {
		if (project.hasProperty('gaeEmail')) {
			email = gaeEmail
		}
	}
}